---
- name: Create Traefik & Socket Proxy
  vars:
    app_name: "{{ dc_traefik_container_name }}" # "traefik"
    traefik_crowdsec_bouncer_key: "{{ dc_traefik_crowdsec_bouncer_key }}" # ! MUST BE HERE BECAUSE SHARED !
  block:
  # * ------------------------ Traefik Network ------------------------ * #
    - name: Include Traefik Network
      ansible.builtin.import_role:
        name: dn_traefik_net

  # * ------------------------ CrowdSec ------------------------ * #
    - name: Include crowdsec role
      ansible.builtin.import_role:
        name: dc_crowdsec
      when: dc_traefik_crowdsec_enabled

  # * ------------------------ Socket Proxy ------------------------ * #
    - name: Include Socket Proxy role
      ansible.builtin.import_role:
        name: dc_socketproxy
      vars:
        dc_socketproxy_env_log_level: "{{ dc_traefik_socketproxy_env_log_level }}"
        dc_socketproxy_env_containers: "{{ dc_traefik_socketproxy_env_containers }}"
        dc_socketproxy_net_cidr: "{{ dc_traefik_socketproxy_net_cidr }}"
        dc_socketproxy_net_ip: "{{ dc_traefik_socketproxy_net_ip }}"

  # * ----------------------- Traefik App ------------------------- * #
    - name: Create app
      vars:
        container_type: "app" # => app, db, redis
        user: "{{ (dc_traefik_create_with_userns | bool) | ternary(dc_traefik_u_g_id + 100000, dc_traefik_u_g_id) }}"
        group: "{{ (dc_traefik_create_with_userns | bool) | ternary(dc_traefik_u_g_id + 100000, dc_traefik_u_g_id) }}"
      block:
        - name: '[Required] filesystem_manager role'
          ansible.builtin.import_role:
            name: filesystem_manager
          vars:
            filesystem_manager_appdata_directories_to_create:
              - path: "rules"
              - path: "letsencrypt"
              - path: "plugins-storage"
            filesystem_manager_appdata_files_to_touch:
              - filename: "letsencrypt/acme.json"
                mode: "0600"
            filesystem_manager_log_files_to_touch:
              - filename: "traefik.log"
              - filename: "access.log"
            filesystem_manager_appdata_templates_in_directory_to_copy:
              - src: "{{ playbook_dir | dirname }}/roles/dc_traefik/templates/shared"
                dest: "rules"
              - src: "{{ playbook_dir | dirname }}/roles/dc_traefik/templates/{{ dc_traefik_type }}"
                dest: "rules"
            filesystem_manager_secret_files_to_create:
              - var_name: "basic_auth_credentials"
                content: "{{ dc_traefik_basic_auth_user }}:{{ dc_traefik_basic_auth_password_hashed }}"
                mode: "0440"
              - var_name: "dc_traefik_cf_dns_api_token"
                content: "{{ dc_traefik_cf_dns_api_token }}" # pass it from the ansible vault
                mode: "0440"

        - name: '[Required] filesystem_manager role'
          ansible.builtin.import_role:
            name: filesystem_manager
          vars:
            filesystem_manager_secret_files_to_create:
              - var_name: "traefik_crowdsec_bouncer_key"
                content: "{{ traefik_crowdsec_bouncer_key | default('') }}"
                set_facts: true  # optional - needed for the app
                # overide_existing: true  # optional
          when: dc_traefik_crowdsec_enabled | bool

        - name: Install docker compose traefik with inline definition
          vars:
            docker_networks: >-
              {{
                {
                  "traefik_net": {
                    "name": dc_traefik_net_name,
                    "external": true
                  },
                  "socketproxy_net": {
                    "name": app_name ~ "_socketproxy_net",
                    "external": true
                  }
                }
                | combine(
                  {
                    "crowdsec_net": {
                      "name": "crowdsec_net",
                      "external": true
                    }
                  }
                  if dc_traefik_crowdsec_enabled else {}
                )
              }}

          community.docker.docker_compose_v2:
            project_name: "{{ app_name }}"
            definition:
              # ! --------------------------- Networks --------------------------- ! #
              networks: "{{ docker_networks }}"


              # * ---------------------------- App ------------------------------ * #
              services:
                traefik:
                  container_name: "{{ app_name }}"  # eg: traefik
                  image: traefik:{{ dc_traefik_image_version }}
                  # profiles: ["core", "all"] # ! seams not to work here
                  restart: always
                  # read_only: true # needs to rewrite the acme and such
                  security_opt:
                    - no-new-privileges:true
                  privileged: false
                  userns_mode: "{{ 'host' if dc_traefik_create_with_userns | bool == false else 'remap' }}"
                  user: "{{ dc_traefik_u_g_id }}:{{ dc_traefik_u_g_id }}"
                  command: # CLI arguments
                    - --global.checkNewVersion=true
                    - --global.sendAnonymousUsage=false
                    - --entrypoints.web.address=:80
                    - --entrypoints.websecure.address=:443
                    - --entrypoints.traefik.address=:8080
                    # - --entrypoints.ping.address=:8081
                    - --entrypoints.web.http.redirections.entrypoint.to=websecure
                    - --entrypoints.web.http.redirections.entrypoint.scheme=https
                    - --entrypoints.web.http.redirections.entrypoint.permanent=true
                    - --api=true
                    - --api.dashboard=true
                    - --api.insecure=true # http://ip:8080/dashboard/#/
                    # - --ping=true
                    - --serversTransport.insecureSkipVerify=true  # uncomment with https containers internally
                    # Allow these IPs to set the X-Forwarded-* headers - Cloudflare IPs: https://www.cloudflare.com/ips/
                    - --entrypoints.websecure.forwardedHeaders.trustedIPs={{ dc_traefik_cloudflare_ip_ranges }}{{ ',' + dc_traefik_local_ip_ranges if dc_traefik_local_ip_ranges is defined and dc_traefik_local_ip_ranges | length > 0 }}
                    - --log=true
                    - --log.filePath=/logs/traefik.log  # (Default: stdout)
                    - --log.level={{ dc_traefik_log_level }} # (Default: error)(info for grafana & crowdsec logs) DEBUG, INFO, WARN, ERROR, FATAL, PANIC
                    - --accessLog=true
                    - --accessLog.filePath=/logs/access.log # (Default: stdout)
                    # - --accessLog.bufferingSize=100 # Configuring a buffer of 100 lines
                    - --accessLog.filters.statusCodes=204-299,400-499,500-599
                    - --accessLog.filters.retryAttempts=true  # Log retry attempts
                    - --accessLog.filters.minDuration=100ms # logging slow requests
                    # - --accessLog.fields.headers.defaultMode=drop
                    # - --accessLog.fields.headers.names.X-Forwarded-For=keep
                    # - --accessLog.fields.headers.names.Authorization=keep
                    - --providers.docker=true
                    # - --providers.docker.endpoint=unix:///var/run/docker.sock # Use Docker Socket Proxy instead for improved security
                    - --providers.docker.endpoint=tcp://{{ app_name }}-socketproxy:2375 # Enable for Socket Proxy. Disable otherwise.  # eg: traefik-socketproxy:2375
                    - --providers.docker.exposedByDefault=false
                    - --providers.docker.network={{ dc_traefik_net_name }}
                    # - --providers.docker.swarmMode=false # Traefik v2 Swarm
                    # - --providers.swarm.endpoint=tcp://127.0.0.1:2377 # Traefik v3 Swarm
                    - --entrypoints.websecure.http.tls=true
                    - --entrypoints.websecure.http.tls.options=tls-opts@file
                    # * ------------------- Cloudflare with ACME ------------------- * #
                    # Add dns-cloudflare as default certresolver for all services. Also enables TLS and no need to specify on individual services
                    - --entrypoints.websecure.http.tls.certresolver=dns-cloudflare
                    - --entrypoints.websecure.http.tls.domains[0].main={{ domain_1 }}
                    - --entrypoints.websecure.http.tls.domains[0].sans=*.{{ domain_1 }}
                    # - --entrypoints.websecure.http.tls.domains[1].main=internal.{{ domain_1 }} # Pulls main cert for internal domain
                    # - --entrypoints.websecure.http.tls.domains[1].sans=*.internal.{{ domain_1 }} # Pulls wildcard cert for internal domain
                    - --providers.file.directory=/rules # Load dynamic configuration from one or more .toml or .yml files in a directory
                    - --providers.file.watch=true # Only works on top level files in the rules folder
                    - "{{ '--certificatesResolvers.dns-cloudflare.acme.caServer=https://acme-staging-v02.api.letsencrypt.org/directory' if dc_traefik_acme_staging_mode | bool else '' }}" # ? LetsEncrypt Staging Server - uncomment when testing
                    - --certificatesResolvers.dns-cloudflare.acme.storage=/letsencrypt/acme.json
                    - --certificatesResolvers.dns-cloudflare.acme.dnsChallenge.provider=cloudflare
                    - --certificatesResolvers.dns-cloudflare.acme.dnsChallenge.resolvers=1.1.1.1:53,1.0.0.1:53
                    - --certificatesResolvers.dns-cloudflare.acme.dnsChallenge.delayBeforeCheck=60 # 90 # To delay DNS check and reduce LE hitrate
                    # - --metrics.prometheus=true
                    # - --metrics.prometheus.buckets=0.1,0.3,1.2,5.0
                    # - --metrics.prometheus.addEntryPointsLabels=true
                    # - --metrics.prometheus.addrouterslabels=true
                    # - --metrics.prometheus.addServicesLabels=true
                    # - --metrics.influxdb2=true
                    # - --metrics.influxdb2.address=http://192.168.10.111:8086
                    # - --metrics.influxdb2.token=$INFLUXDB_TOKEN
                    # - --metrics.influxdb2.org=zHome
                    # - --metrics.influxdb2.bucket=traefik-ws
                    # - --metrics.influxdb2.addEntryPointsLabels=true
                    # - --metrics.influxdb2.addrouterslabels=true
                    # - --metrics.influxdb2.addServicesLabels=true
                    # - --metrics.influxdb2.pushInterval=30s
                    # - --metrics.influxdb2.additionallabels.host=$DOMAINNAME_1
                    # * ------------------- Plugins ------------------- * #
                    - "{{ '--experimental.plugins.crowdsec-bouncer-traefik-plugin.modulename=github.com/maxlerebourg/crowdsec-bouncer-traefik-plugin' if dc_traefik_crowdsec_enabled | bool else '' }}"
                    - "{{ '--experimental.plugins.crowdsec-bouncer-traefik-plugin.version=v1.3.3' if dc_traefik_crowdsec_enabled | bool else '' }}"
                  # extra_hosts:  # Just rly needed if using both traefiks together
                  #   - "traefik-ingress.{{ domain_1 }}:{{ dc_dmz_net_vm10_ingress_ip }}"  # Yes, this is correct!
                  #   - "traefik-metrics.{{ domain_1 }}:{{ dc_dmz_net_vm20_metrics_ip }}"  # Yes, this is correct!
                  networks:
                    traefik_net: "{{ {'ipv4_address': dc_traefik_net_ip} if dc_traefik_net_ip is defined and dc_traefik_net_ip | length > 0 else {} }}"
                    socketproxy_net: "{{ {'ipv4_address': dc_traefik_socketproxy_net_app_ip} if dc_traefik_socketproxy_net_app_ip is defined and dc_traefik_socketproxy_net_app_ip | length > 0 else {} }}"
                    crowdsec_net: "{{ {'ipv4_address': dc_crowdsec_net_traefik_ip} if dc_crowdsec_net_traefik_ip is defined and dc_crowdsec_net_traefik_ip | length > 0 and dc_traefik_crowdsec_enabled | default(false) | bool else omit }}"
                  ports:
                    - target: 80
                      published: 80
                      protocol: tcp
                      mode: host
                    - target: 443
                      published: 443
                      protocol: tcp
                      mode: host
                    - target: 8080 # need to enable --api.insecure=true
                      published: 8080
                      protocol: tcp
                      mode: host
                  volumes:
                    # - /var/run/docker.sock:/var/run/docker.sock:ro # Enable if not using Socket Proxy
                    - "{{ appdata_type_path }}/rules:/rules" # Dynamic File Provider directory
                    - "{{ appdata_type_path }}/plugins-storage:/plugins-storage"
                    # - "{{ appdata_type_path }}/acme.json:/acme.json" # Certs File
                    - "{{ appdata_type_path }}/letsencrypt:/letsencrypt" # Certs Files
                    - "{{ logs_type_path }}:/logs" # Traefik logs
                    - "{{ secrets_type_path }}:/run/secrets"
                  environment:
                    TZ: "{{ timezone }}"
                    CF_DNS_API_TOKEN_FILE: /run/secrets/dc_traefik_cf_dns_api_token
                  labels:
                    # - autoheal: "true"
                    traefik.enable: "true"
                    # * Healthcheck/ping
                    # - "traefik.http.routers.ping.rule=Host(`traefik.$DOMAINNAME_HS`) && Path(`/ping`)"
                    # - "traefik.http.routers.ping.tls=true"
                    # - "traefik.http.routers.ping.service=ping@internal"
                    # * HTTP Routers
                    traefik.http.routers.traefik-rtr.entrypoints: "websecure"
                    traefik.http.routers.traefik-rtr.rule: "Host(`{{ app_name }}-{{ dc_traefik_type }}.{{ domain_1 }}`)"
                    # * Services - API
                    traefik.http.routers.traefik-rtr.service: "api@internal"
                    # * Middlewares
                    # traefik.http.routers.traefik-rtr.middlewares: "chain-no-auth@file" # For No Authentication
                    # traefik.http.routers.traefik-rtr.middlewares: "chain-basic-auth@file" # For Basic HTTP Authentication
                    # traefik.http.routers.traefik-rtr.middlewares: "chain-oauth@file" # For Google OAuth
                    # traefik.http.routers.traefik-rtr.middlewares: "chain-authelia@file" # For Authelia Authentication
                    traefik.http.routers.traefik-rtr.middlewares: "{{ 'chain-authelia@file' if dc_traefik_type == 'ingress' else 'chain-basic-auth@file' }}"


                # traefik-certs-dumper:
                #   container_name: "{{ app_name }}-certs-dumper"
                #   image: ldez/traefik-certs-dumper:v2.8.3
                #   restart: unless-stopped
                #   # read_only: true # needs to rewrite the acme and such
                #   security_opt:
                #     - no-new-privileges:true
                #   privileged: false
                #   entrypoint: sh -c '
                #     apk add jq
                #     ; while ! [ -e /data/acme.json ]
                #     || ! [ `jq ".[] | .Certificates | length" /data/acme.json` != 0 ]; do
                #     sleep 1
                #     ; done
                #     && traefik-certs-dumper file --domain-subdir=true
                #     --version v2 --watch
                #     --source /data/acme.json --dest /certs_dumper'
                #   networks:
                #     traefik_net: "{{ {'ipv4_address': dc_traefik_net_cert_dumper_ip} if dc_traefik_net_cert_dumper_ip is defined and dc_traefik_net_cert_dumper_ip | length > 0 else {} }}"
                #   volumes:
                #     - "{{ appdata_type_path }}/letsencrypt:/data"
                #     - "{{ docker_secrets }}/certs_dumper:/certs_dumper"
